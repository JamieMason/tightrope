"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[8296],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>d});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},s=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u="mdxType",f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,p=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),u=l(n),m=o,d=u["".concat(p,".").concat(m)]||u[m]||f[m]||i;return n?r.createElement(d,a(a({ref:t},s),{},{components:n})):r.createElement(d,a({ref:t},s))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c[u]="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5087:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>a,default:()=>f,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const i={id:"flow",title:"flow",tags:["composition"]},a=void 0,c={unversionedId:"api/fn/flow",id:"api/fn/flow",title:"flow",description:"Creates a function which pipes its input through a sequence of functions in left-to-right order.",source:"@site/docs/api/fn/flow.mdx",sourceDirName:"api/fn",slug:"/api/fn/flow",permalink:"/tightrope/api/fn/flow",draft:!1,editUrl:"https://github.com/JamieMason/tightrope/tree/master/site/docs/api/fn/flow.mdx",tags:[{label:"composition",permalink:"/tightrope/tags/composition"}],version:"current",frontMatter:{id:"flow",title:"flow",tags:["composition"]},sidebar:"sidebar",previous:{title:"curry",permalink:"/tightrope/api/fn/curry"},next:{title:"get",permalink:"/tightrope/api/fn/get"}},p={},l=[{value:"Example",id:"example",level:2}],s={toc:l},u="wrapper";function f(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Creates a function which pipes its input through a sequence of functions in left-to-right order."),(0,o.kt)("p",null,"A higher-order function that takes any number of functions as its arguments and returns a new function that applies\neach function in sequence, passing the result of each function as the argument to the next function."),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"In this example, we first define three functions: ",(0,o.kt)("inlineCode",{parentName:"p"},"addOne"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"double"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"square"),". We then use the ",(0,o.kt)("inlineCode",{parentName:"p"},"flow")," function\nto create a new function ",(0,o.kt)("inlineCode",{parentName:"p"},"composedFn")," that composes these three functions together. We can then call ",(0,o.kt)("inlineCode",{parentName:"p"},"composedFn"),"\nwith an argument to get the result of applying the composed functions in sequence."),(0,o.kt)("p",null,"Note that the flow function applies the functions in left to right order, so the first function given as an argument\nis applied first."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { flow } from 'tightrope/fn/flow';\n\n// Define some functions to compose\nfunction addOne(n: number): number {\n  return n + 1;\n}\n\nfunction double(n: number): number {\n  return n * 2;\n}\n\nfunction square(n: number): number {\n  return n * n;\n}\n\n// Use flow to create a new function that composes the other functions\nconst composedFn = flow(addOne, double, square);\n\n// Call the composed function with an argument\nconst result = composedFn(3); // returns 64\n")))}f.isMDXComponent=!0}}]);