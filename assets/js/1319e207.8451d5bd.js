"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[1440],{3905:(e,t,n)=>{n.d(t,{Zo:()=>s,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),c=u(n),f=a,d=c["".concat(l,".").concat(f)]||c[f]||m[f]||o;return n?r.createElement(d,i(i({ref:t},s),{},{components:n})):r.createElement(d,i({ref:t},s))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=f;var p={};for(var l in t)hasOwnProperty.call(t,l)&&(p[l]=t[l]);p.originalType=e,p[c]="string"==typeof e?e:a,i[1]=p;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},1432:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>p,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const o={id:"map",title:"map"},i=void 0,p={unversionedId:"api/gen/map",id:"api/gen/map",title:"map",description:"A higher-order function that takes a function as its argument and returns a",source:"@site/docs/api/gen/map.mdx",sourceDirName:"api/gen",slug:"/api/gen/map",permalink:"/ts-lib/api/gen/map",draft:!1,editUrl:"https://github.com/JamieMason/ts-lib/tree/master/site/docs/api/gen/map.mdx",tags:[],version:"current",frontMatter:{id:"map",title:"map"},sidebar:"sidebar",previous:{title:"filter",permalink:"/ts-lib/api/gen/filter"},next:{title:"range",permalink:"/ts-lib/api/gen/range"}},l={},u=[],s={toc:u},c="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(c,(0,r.Z)({},s,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A higher-order function that takes a function as its argument and returns a\nnew function that can be used to transform values from a generator."),(0,a.kt)("p",null,"The returned function takes a generator as its argument and returns a new\ngenerator that yields the transformed values."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"map")," function applies the transformation function to each value\ngenerated by the input generator, and yields the transformed values in the\noutput generator. The transformation function can be any function that takes\na single input value and returns a single output value of any type."),(0,a.kt)("p",null,"In summary, the ",(0,a.kt)("inlineCode",{parentName:"p"},"map")," function is a powerful tool for working with generators\nin JavaScript and TypeScript. By using it to transform values from a\ngenerator, we can easily create new generators that yield the transformed\nvalues according to our specific criteria. This can help us write more\nefficient and focused code, and can make it easier to work with large or\ncomplex data sets."),(0,a.kt)("p",null,"In this example, we use the ",(0,a.kt)("inlineCode",{parentName:"p"},"pipe")," function to create a pipeline of\ngenerators and maps that double the values generated by the range function."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { pipe } from 'ts-lib/fn/pipe';\nimport { map } from 'ts-lib/gen/map';\nimport { multiply } from 'ts-lib/number/multiply';\nimport { range } from 'ts-lib/gen/range';\nimport { take } from 'ts-lib/gen/take';\n\nconst doubledNumbers = pipe(range(0, 100), map(multiply(2)), take(5));\n\nfor (const value of doubledNumbers) {\n  console.log(value);\n}\n")),(0,a.kt)("p",null,"We start with the ",(0,a.kt)("inlineCode",{parentName:"p"},"range")," function, which generates a sequence of numbers\nstarting from ",(0,a.kt)("inlineCode",{parentName:"p"},"0"),". We then apply the ",(0,a.kt)("inlineCode",{parentName:"p"},"map")," function to the pipeline to double\neach value generated by the ",(0,a.kt)("inlineCode",{parentName:"p"},"range")," function, and then apply the ",(0,a.kt)("inlineCode",{parentName:"p"},"take"),"\nfunction to limit the number of values generated to ",(0,a.kt)("inlineCode",{parentName:"p"},"5"),"."),(0,a.kt)("p",null,"Finally, we use a ",(0,a.kt)("inlineCode",{parentName:"p"},"for...of")," loop to iterate over the 5 doubled numbers\ngenerated by the pipeline, and log them to the console."),(0,a.kt)("p",null,"When we run this example, we should see the following output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"// 2\n// 4\n// 6\n// 8\n// 10\n")))}m.isMDXComponent=!0}}]);